<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="description" content="depth first search path finding algorithm">
	<meta name="keywords"
		content="depth first search, depth first algorithm, depth first traversal, path finding, graph algorithms, algorithms, visualization, visual, graphs, graph traversal, traversal">
	<meta name="author" content="lumunge">
	<link rel="stylesheet" href="../assets/css/visual/index.css">
	<link rel="stylesheet" href="../assets/css/visual/pathFinding.css">
	<title>Depth first search path finding algorithm.</title>
</head>

<body>
	<nav>
		<a href="../index.html">OpenGenus Visuals</a>
		<a href="./bfs-visual.html">bfs</a>
		<a href="./dfs-visual.html">dfs</a>
		<a href="./dijkstra-visual.html">dijkstra’s</a>
		<a href="./islands-visual.html">num islands</a>
		<a href="./maxIsland-visual.html">max island</a>
	</nav>
	<header>
		<div class="heading">
			<h2 class="algorithm dfs">Depth first search</h2>
			<hr>
		</div>
		<div class="controlsContainer">
			<div class="visualControls">
				<div class="visualSpeed">
					<p>Speed</p>
					<input type="range" min="1" max="20" value="10" class="speedSlider" />
				</div>
				<div class="obstacles">
					<p>Obstacles</p>
					<div class="obstaclesElements">
						<input type="range" min="1" value="50" class="obstacleSlider" />
						&nbsp;
						<button class="setWalls btn">walls</button>
					</div>
				</div>
				<div class="controlBtns">
					<button class="start btn">start</button>
					<button class="clearPath btn">clear path</button>
					<button class="reset btn">reload</button>
					<select style="display: none;" class="islandsAlgo">
						<option></option>
					</select>
				</div>
				<div class="tutorialContainer">
					<span><img class="info" src="../assets/images/icons8-info-60.png" alt=""></span>
					<div class="tutorialContent">
						<h4>Controls</h4>
						<p><span>Speed</span> - increase or decrease the speed of the visualization</p>
						<p><span>Obstacles-</span> - create walls/obstacles, on a map these can be buildings or
							structures which hinder a path. You can adjust the number of obstacles generated per click.
							<br /> - You can also click on the grid cells to create
							obstacles.
						</p>
						<p><span>Start</span> - After adjusting the speed and creating obstacles, you can now start the
							visualization to see the workings of the algorithm.</p>
						<p><span>Clear Path</span> - After visualizing, you may opt to clear the path and add more
							obstacles.</p>
						<p><span>Speed</span> - If the grid becomes to cluttered you can reload it and repeat the above
							steps.</p>
					</div>
				</div>
			</div>
			<!-- not displayed -->
			<div class="hide">
				<select class="algo">
					<option value=""></option>
				</select>
				<select class="weight">
					<option value=""></option>
				</select>
			</div>
		</div>
	</header>
	<main>
		<div class="visualizationContainer">
			<div id="gridContainer"></div>
			<div class="tutorials">
				<div class="tutorial">
					<div class="emptyPath"></div>&nbsp;
					<div>This is an empty path without any walls, you can click is to add obstacles/walls.</div>
				</div>
				<div class="tutorial">
					<div class="stedimg"><span class="txt">A</span></div>&nbsp;
					<div>Start Node -> this is the starting point(source),
						search for a path starts here.</div>
				</div>
				<div class="tutorial">
					<div class="stedimg"><span class="txt">B</span></div>&nbsp;
					<div>End Node -> where the search stops when a path to destination has been found</div>
				</div>
				<div class="tutorial">
					<div class="obstacle"></div>&nbsp;
					<div>These act as obstacles, walls. On a real map these may be buildings or structures that may
						block
						a shorter path to a destination.</div>
				</div>
				<div class="tutorial">
					<div class="selectedPath"><span class="txt">7</span></div>&nbsp;
					<div>After the algorithm is complete, we have arrived at the destination, now the shortest path is
						highlighted in green with the cost of path written written in black inside the path.</div>
				</div>
			</div>
			<div class="algoInfo">
				<div>
					<div class="infoHeading">
						<h3 class="title">Depth first traversal.</h3>
					</div>
					<p>
						This algorithm starts its search at the root and
						explores one of its children's subtree and then moves
						on to the next child's subtree and etcetera <br />
						The idea used is to go as deep into the graph as
						possible and backtrack once we reach a vertex with
						unvisited neighbors. <br />
						That is, start search at one vertex, after visiting
						the vertex, perform dfs for each unvisited adjacent
						vertex. In this way we visit all vertices reachable
						from the starting vertex. <br />
						We use a <b><em>stack</em></b> data structure.
					</p>
					<div>
						<p class="subtitle">Algorithm</p>
						<p>
							1. Mark the current node as visited(initially
							current node is the root node).
						</p>
						<p>
							2. Check if current node is the goal, If so,
							then return it.
						</p>
						<p>
							1. Iterate over children nodes of current node,
							and do the following:
						</p>
						<p class="nest1">
							2. Check if a child node is not visited.
						</p>
						<p class="nest1">
							1.If so, then, mark it as visited.
						</p>
						<p class="nest1">
							3. Go to it's sub tree recursively until you
							find the goal node(In other words, do the same
							steps here passing the child node as the current
							node in the next recursive call).
						</p>
						<p class="nest1">
							4. If the child node has the goal node in this
							sub tree, then, return it.
						</p>
						<p>
							3. If goal node is not found, then goal node is
							not in the tree!
						</p>
					</div>
					<div>
						<p class="subtitle">Computational complexity</p>
						This algorithm takes <b><em>O(V + E)</em></b> where v is the number of
						vertices and e is the number of edges.
					</div>
					<div>
						<p class="subtitle">Applications</p>
						<ul>
							<li>topological sorting.</li>
							<li>bipartite graph testing.</li>
							<li>finding strongly connected components.</li>
							<li>
								solving puzzles that can only have one
								solution.
							</li>
							<li>detecting cycles in a graph.</li>
						</ul>
					</div>
					<div class="reference">
						<a href="https://iq.opengenus.org/bfs-graph-traversal/">reference</a>
					</div>
				</div>
			</div>
		</div>
	</main>
	<footer>
		<div class="copy">
			<p>OpenGenus IQ © 2021 All rights reserved ™ [email: <a
					href="mailto:team@opengenus.org">team@opengenus.org]</a></p>
		</div>
		<div class="links">
			<span><a href="https://iq.opengenus.org/"> Top Posts </a></span>
			<span><a href="https://www.linkedin.com/company/opengenus"> LinkedIn</a></span>
			<span><a href="https://twitter.com/OpenGenus"> Twitter</a></span>
		</div>
	</footer>
	<script type="module" src="../assets/js/visual/Grid/index.js"></script>
</body>

</html>